package cn.pxl.niuke;

import java.util.HashMap;
import java.util.Scanner;

//HJ16 购物单
//王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
//如果要买归类为附件的物品，必须先买该附件所属的主件，且每件物品只能购买一次。
//每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。
//王强查到了每件物品的价格（都是 10 元的整数倍），而他只有 N 元的预算。除此之外，他给每件物品规定了一个重要度，用整数 1 ~ 5 表示。他希望在花费不超过 N 元的前提下，使自己的满意度达到最大。
//满意度是指所购买的每件物品的价格与重要度的乘积的总和
//请你帮助王强计算可获得的最大的满意度。
//输入的第 1 行，为两个正整数N，m，用一个空格隔开：
//（其中 N （ N<32000 ）表示总钱数， m （m <60 ）为可购买的物品的个数。）
//从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
//（其中 v 表示该物品的价格（ v < 10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）
//输出一个正整数，为张强可以获得的最大的满意度。
public class HJ16 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int money = sc.nextInt();//总钱数 1000
        int n = sc.nextInt(); //总共几件物品 5
        if(n<=0||money<=0) System.out.println(0);
        good[] Gs = new good[n+1];//+1的目的是让数组创建0~5的下标,否则为0~4
        for(int i = 1; i <= n; i++){//遍历1~5件物品
            int v = sc.nextInt(); //物品价格 800，400，300，400，500
            int p = sc.nextInt(); //物品重要度2   ,5,   5,   3,   2
            int q = sc.nextInt(); //物品主附件0   ,1,   1,   0,   0
            Gs[i] = new good(v,p,q);//将一个物品存入对象存入数组

            if(q>0){//如果q>0为附件,且q此时表示主件的下标
                if(Gs[q].a1==0){//如果第一个附件不存在
                    //那么将当前附件对象在数组中的下标放入其父主件的附件1中
                    Gs[q].setA1(i);
                } else {
                    //如果父主件的附件1有值,则存入附件2中
                    Gs[q].setA2(i);
                }
            }
        }
        int[][] dp = new int[n+1][money+1];//创建y轴=物品编号,x轴=剩余金额
        for(int i = 1; i <= n; i++){
            //主件的价格,主件+附件1的价格,主件+附件2的价格,主件+附件1+附件2的价格
            //主件的满意度,主件+附件1的满意度,主件+附件2的满意度,
            //主件+附件1+附件2的满意度
            int v=0,v1=0,v2=0,v3=0,tempdp=0,tempdp1=0,tempdp2=0,tempdp3=0;

            v = Gs[i].v; //获取1~5件仅物品(主件/附件)的价格

            //第一个方案,求物品1~5位主件加附件0(如果只有主件,等于原始背包->方案固定)
            tempdp = Gs[i].p*v; //获取1~5件仅物品的满意度(价格p*重要度v)

            //第二个方案,求物品1~5主件+附件1的总价格,总满意度
            if(Gs[i].a1!=0){//判断1~5件物品是否有附件,有附件为主件执行下列代码
                v1 = Gs[Gs[i].a1].v+v;//有附件将附件1的价格+当前物品的价格
                //获取1~5件主件+附件1的满意度(主件满意度pv+附件1满意度f1v*f1p)
                tempdp1 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p;
            }
            //第三个方案,求物品1~5为主件+附件2的总价格,总满意度(主件满意度pv+附件2满意度f2v*f2p)
            if(Gs[i].a2!=0){
                v2 = Gs[Gs[i].a2].v+v;
                tempdp2 = tempdp + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }
            //第四个方案,求物品1~5为主件+附件1+附件2的总价格,总满意度
            if(Gs[i].a1!=0 && Gs[i].a2!=0){
                v3 = Gs[Gs[i].a1].v+Gs[Gs[i].a2].v+v;
                tempdp3 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p
                        + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }
            //从1块钱 到1000块钱遍历
            for(int j=1; j<=money; j++){
                if(Gs[i].q!=0){ //如果为附件,只有一种方案,即永远不存,值永远为0
                    dp[i][j] = dp[i-1][j];//如果为附件不存,二位数组值=满意度永远为0
                }else {
                    //如果为主件,默认不存,剩余n-1个物品,金额不变,并将该方案的满意度
                    //暂时(如钱>当前主件的价格)或
                    //永久(如钱<当钱主件的价格)存储到当前物品的最大满意度值中
                    dp[i][j] = dp[i-1][j];
                    //如果钱>主件方案的价格,且主件方案价格不等于0,即主件方案存在
                    if(j>=v && v!=0){
                        //那么将比较不存(坐标[商品数量-1,钱不变]位置的满意度)
                        //和存(坐标[商品数量-1][钱-主件方案价格]的满意度+主件方案满意度)的最大值返回
                        dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v]+tempdp);
                    }
                    if(j>=v1 && v1!=0){//如果钱>主件附件1方案的价格,且主件附件1方案存在
                        //将不存方案和主件方案比较,较大满意度的和
                        //存(坐标[商品数量-1][钱-主件附件1方案价格]的满意度
                        //   +主件附件1方案满意度)的最大值存入当前坐标,即最大满意度值
                        dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v1]+tempdp1);
                    }
                    if(j>=v2 && v2!=0){//如果钱>主件附件1方案的价格,且主件附件1方案存在
                        //将不存方案和主件方案和主件附件1方案比较,较大满意度的和
                        //存(坐标[商品数量-1][钱-主件附件2方案价格]的满意度
                        //   +主件附件2方案满意度)的最大值存入当前坐标,即最大满意度值
                        dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v2]+tempdp2);
                    }
                    if(j>v3 && v3!=0){//如果钱>主件附件12方案的价格,且主件附件12方案存在
                        //将不存方案和主件方案和主件附件1方案和主件附件2比较,较大满意度的和
                        //存(坐标[商品数量-1][钱-主件附件12方案价格]的满意度
                        //   +主件附件12方案满意度)的最大值存入当前坐标,即最大满意度值
                        dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v3]+tempdp3);
                    }
                }
            }
        }
        //输出该数组右下角最大满意度值(坐标[最大物品数][最大金钱数])即可
        System.out.println(dp[n][money]);
    }

    private static class good{
        public int v; //物品价格
        public int p; //物品重要度
        public int q; //物品主附件ID

        public int a1=0; //附件1ID
        public int a2=0; //附件2Id

        public good(int v,int p,int q){
            this.v = v;
            this.p = p;
            this.q = q;
        }
        public void setA1(int a1){
            this.a1 = a1;
        }
        public void setA2(int a2){
            this.a2 = a2;
        }

    }
}
